---
- name: Install a simple dev/test site on our dev servers only
  hosts: all
  become: true

  vars_files:
    - vars.yml

  pre_tasks:

  tasks:
    - name: Create siteroot folders
      ansible.builtin.file:
        path: "{{ item.siteroot }}"
        state: directory
        mode: '0755'
        owner: "{{ item.siteroot_owner | default(default_apache_user) }}"
        group: "{{ item.siteroot_group | default(default_apache_group) }}"
      loop: "{{ websites }}"
      when: item.siteroot is defined

    - name: Create docroot folders
      ansible.builtin.file:
        path: "{{ item.docroot }}"
        state: directory
        mode: '0755'
        owner: "{{ item.docroot_owner | default(default_apache_user) }}"
        group: "{{ item.docroot_group | default(default_apache_group) }}"
      loop: "{{ websites }}"
      # Some websites will have the docroot as a symlink to a current directory, so
      # we don't want to create it as a directory. Apache won't die if it doesn't
      # exist.
      when: item.create_docroot | default(true)

    - name: Create corresponding well-known directory with acme-challenge subdirectory
      ansible.builtin.file:
        # The path is designed so you can point webroot at acme_well_known_dir/server_name and
        # things will work as if that was the webroot of the real site.
        path: "{{ acme_well_known_dir }}/{{ item.server_name }}/.well-known/acme-challenge"
        state: directory
        mode: '0755'
        owner: root
        group: root
      loop: "{{ websites }}"

    - name: Template standard security.txt to well-known directory
      ansible.builtin.template:
        src: security.txt.j2
        dest: "{{ acme_well_known_dir }}/{{ item.server_name }}/.well-known/security.txt"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"

    - name: Install straight http configurations for all sites
      ansible.builtin.template:
        src: http-site.conf.j2
        dest: "{{ apache_server_root }}/sites-available/{{ site.apache_config_name | default(site.server_name) }}.conf"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      notify: Reload apache

    - name: Install https configurations for all sites
      ansible.builtin.template:
        src: "https-site.conf.j2"
        dest: "{{ apache_server_root }}/sites-available/{{ site.apache_config_name | default(site.server_name) }}-ssl.conf"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      notify: Reload apache

    - name: Set up default site
      ansible.builtin.import_tasks:
        file: default-site.yml

    # The http versions of the sites don't do anything special; they just redirect to https
    - name: Enable all http sites
      ansible.builtin.command: a2ensite {{ site.apache_config_name | default(site.server_name) }}
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      notify: Reload apache
      register: site_result
      changed_when: "'Enabling site' in site_result.stdout"

    # The https versions of the sites will use a letsencrypt certificate if it's
    # available, otherwise they'll all use the same snakeoil self-signed cert that's
    # generated by ssl-cert. This means it's safe to enable them immediately, and
    # if they've not a letsencrypt certificate, they'll run well enough to use
    # cerbot's http validation to *get* the letsencrypt certificate, at which point
    # we reload apache and they'll start using the new certificate.
    - name: Enable all https sites
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      ansible.builtin.command: "a2ensite {{ site.apache_config_name | default(site.server_name) }}-ssl"
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # At this point we should be able to get our sites up and running enough to
    # pass an ACME challenge, so run handlers to reload apache and get the sites
    # up and running.
    - name: Flush handlers
      ansible.builtin.meta: flush_handlers

    - name: Set certs fact for certbot
      ansible.builtin.set_fact:
        certs: >-
          {{ certs | default([]) +
          [ {
            'domains': [ item.server_name ] + (item.aliases | default([])),
            'email': acme_email,
            'webroot': acme_well_known_dir + '/' + item.server_name
          } ]
          }}
      when: use_letsencrypt
      with_items: "{{ websites }}"
      tags: acme

    - name: Set up Certbot with the certificates set up as above for all websites
      ansible.builtin.import_role:
        name: geerlingguy.certbot
      vars:
        certbot_certs: "{{ certs }}"
        certbot_install_method: snap
        certbot_create_method: webroot
        certbot_create_if_missing: true
        certbot_agree_tos: true
        certbot_auto_renew_hour: "{{ acme_auto_renew_hour }}"
        certbot_auto_renew_minute: "{{ acme_auto_renew_minute }}"
        # NB: certbot_create_extra_args can't be empty with our current role version;
        # see https://github.com/geerlingguy/ansible-role-certbot/issues/225
        certbot_create_extra_args: ''
        # certbot_testmode enables --test-cert, which uses the staging server.
        certbot_testmode: "{{ acme_use_staging_server }}"
        certbot_email: "{{ acme_email }}"
        # TODO: Can/should we do this as some other user? Not sure. What permissions would it need?
        certbot_auto_renew_user: "{{ acme_auto_renew_user }}"
      # Because there's no point in doing this for e.g. vagrant, where letsencrypt won't
      # be able to see our sites anyway, so we need a mechanism for not bothering.
      when: use_letsencrypt
      # Make sure we reload the config, as the switch from snakeoil to letsencrypt is done
      # by IfFile checks in the apache config, so we need to reload to pick up the change.
      notify: Reload apache
      tags: acme

  handlers:

    - name: Reload apache
      ansible.builtin.service:
        name: apache2
        state: reloaded
