---
- name: Install a simple dev/test site on our dev servers only
  hosts: all
  become: true

  vars_files:
    - vars.yml

  # TODO: Pre-tasks to create directories for letsencrypt, etc. and set permissions

  pre_tasks:
    - name: Create necessary directories.
      # The ssl and key directories seem to be there already in Ubuntu, so I'm
      # just matching their existing permissions/ownership.
      ansible.builtin.file:
        path: "{{ item.dir }}"
        state: directory
        mode: "{{ item.mode | default('0755') }}"
        owner: "{{ item.owner | default('root') }}"
        group: "{{ item.group | default('root') }}"
      with_items:
        - dir: "{{ acme_keys_dir }}"
          mode: 'u=rwx,g=x,o=x'
          group: ssl-cert
        - dir: "{{ acme_certs_dir }}"
        - dir: "{{ acme_csr_dir }}"
        - dir: "{{ acme_account_dir }}"

  tasks:
    - name: Create siteroot folders
      ansible.builtin.file:
        path: "{{ item.siteroot }}"
        state: directory
        mode: '0755'
        owner: "{{ item.siteroot_owner }}"
        group: "{{ item.siteroot_group }}"
      loop: "{{ websites }}"
      when: item.siteroot is defined

    - name: Create docroot folders
      ansible.builtin.file:
        path: "{{ item.docroot }}"
        state: directory
        mode: '0755'
        owner: "{{ item.docroot_owner | default(default_docroot_owner) }}"
        group: "{{ item.siteroot_group | default(default_docroot_group) }}"
      loop: "{{ websites }}"

    - name: Create corresponding well-known directory with acme-challenge subdirectory
      ansible.builtin.file:
        # The path is designed so you can point webroot at acme_well_known_dir/server_name and
        # things will work as if that was the webroot of the real site.
        path: "{{ acme_well_known_dir }}/{{ item.server_name }}/.well-known/acme-challenge"
        state: directory
        mode: '0755'
        owner: root
        group: root
      loop: "{{ websites }}"

    - name: Template standard security.txt to well-known directory
      ansible.builtin.template:
        src: security.txt.j2
        dest: "{{ acme_well_known_dir }}/{{ item.server_name }}/security.txt"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"

# TODO: Add a default site
    # - name: Install default site index
    #   ansible.builtin.template:
    #     src: index.html.j2
    #     dest: "{{ dev_site_path }}/index.html"
    #     owner: root
    #     group: root
    #     mode: '0644'

    # - name: Install default site http configuration
    #   ansible.builtin.template:
    #     src: "dev.conf.j2"
    #     dest: "{{ apache_server_root }}/sites-available/{{ dev_conf_name }}"
    #     owner: root
    #     group: root
    #     mode: '0644'
    #   notify: Reload apache

    - name: Install straight http configurations for all sites
      ansible.builtin.template:
        src: http-site.conf.j2
        dest: "{{ apache_server_root }}/sites-available/{{ site.server_name }}.conf"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      notify: Reload apache

    - name: Install https configurations for all sites
      ansible.builtin.template:
        src: "https-site.conf.j2"
        dest: "{{ apache_server_root }}/sites-available/{{ site.server_name }}-ssl.conf"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ websites }}"
      loop_control:
        loop_var: site
      notify: Reload apache

    # TODO: Disable dev site (http and https) if not in production

    # We'll need the http site up and running before we can pass an ACME challenge.
    - name: Enable all http sites
      ansible.builtin.command: a2ensite {{ item.server_name }}
      loop: "{{ websites }}"
      notify: Reload apache
      register: site_result
      changed_when: "'Enabling site' in site_result.stdout"

    # BEFORE we enable the ssl site we've got to provide a self-signed certificate
    # if no SSL certificate is present yet. Later if necessary we can regenerate
    # the certificate with a real one from Let's Encrypt.

    # For this initial key we'll only create it if there's no key certificate of any
    # kind yet.
    - name: Check if any kind of certificate exists
      ansible.builtin.stat:
        path: "{{ acme_certs_dir }}/{{ item.server_name }}.crt"
      register: cert_paths
      loop: "{{ websites }}"

    # - name: Get certificate information
    #   when: cert_path.stat.exists
    #   community.crypto.x509_certificate_info:
    #     path: "{{ dev_cert_path }}"
    #   register: cert_info

    # - name: Print existing certificate information
    #   ansible.builtin.debug:
    #     var: cert_paths.results

    # - name: Arbitrary debugging 3
    #   ansible.builtin.debug:
    #     msg: >-
    #      {{ (cert_paths.results | map(attribute='item.server_name')) |
    #         zip(cert_paths.results | map(attribute='stat.exists'))
    #      }}

    # Filter our websites to only those that don't have a certificate yet
    - name: Find sites with no certificates at all at the moment
      ansible.builtin.set_fact:
        self_signed_certs_needed: >-
         {{ cert_paths.results |
            selectattr('stat.exists', 'equalto', false) |
            map(attribute='item') }}

    - name: Debug sites with no certificates
      ansible.builtin.debug:
        msg: >-
         {{ self_signed_certs_needed | map(attribute='server_name') }}

    - name: Create private keys for self-signed certificates (RSA, 4096 bits)
      loop: "{{ self_signed_certs_needed }}"
      loop_control:
        loop_var: site
      notify: Reload apache
      community.crypto.openssl_privatekey:
        path: "{{ acme_keys_dir }}/{{ site.server_name }}.key"
        regenerate: never
        type: RSA

    - name: Create CSRs for simple self-signed certificate
      loop: "{{ self_signed_certs_needed }}"
      loop_control:
        loop_var: site
      community.crypto.openssl_csr:
        path: "{{ acme_csr_dir }}/{{ site.server_name }}.csr"
        privatekey_path: "{{ acme_keys_dir }}/{{ site.server_name }}.key"
        common_name: "{{ site.server_name }}"
        subject_alt_name: "{{ ([site.server_name] + (site.aliases | default([]))) | map('regex_replace', '^', 'DNS:') | list }}"
        authority_cert_issuer:
          - "{{ self_signed_ca_DNS }}"
        authority_cert_serial_number: 123
      register: csrs

    # - name: Print CSRs
    #   ansible.builtin.debug:
    #     var: csrs.results

    - name: Create simple self-signed certificates
      loop: "{{ self_signed_certs_needed }}"
      loop_control:
        loop_var: site
      community.crypto.x509_certificate:
        path: "{{ acme_certs_dir }}/{{ site.server_name }}.crt"
        csr_path: "{{ acme_csr_dir }}/{{ site.server_name }}.csr"
        privatekey_path: "{{ acme_keys_dir }}/{{ site.server_name }}.key"
        provider: selfsigned
      notify: Reload apache

    - name: Enable all https sites
      loop: "{{ websites }}"
      ansible.builtin.command: "a2ensite {{ item.server_name }}-ssl"
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # At this point we should be able to get our sites up and running enough to
    # pass an ACME challenge, so run handlers to reload apache and get the site
    # up and running.
    - name: Flush handlers
      ansible.builtin.meta: flush_handlers

    - name: Set certs fact for certbot
      ansible.builtin.set_fact:
        certs: >-
          {{ certs | default([]) +
          [ {
            'domains': [ item.server_name ] + (item.aliases | default([])),
            'email': acme_email,
            'webroot': acme_well_known_dir + '/' + item.server_name
          } ]
          }}
      when: use_letsencrypt
      with_items: "{{ websites }}"
      tags: acme

    - name: Debug certbot_certs
      ansible.builtin.debug:
        var: certs
      tags: acme

    - name: Set up Certbot with the certificates set up as above for our websites
      ansible.builtin.import_role:
        name: geerlingguy.certbot
      vars:
        certbot_certs: "{{ certs }}"
        certbot_install_method: snap
        certbot_create_method: webroot
        certbot_create_if_missing: true
        certbot_agree_tos: true
        certbot_auto_renew_hour: "2"
        certbot_auto_renew_minute: "18" # Random.org
        # NB: certbot_create_extra_args can't be empty with our current role version;
        # see https://github.com/geerlingguy/ansible-role-certbot/issues/225
        certbot_create_extra_args: ''
        # certbot_testmode enables --test-cert, which uses the staging server.
        certbot_testmode: "{{ acme_use_staging_server }}"
        certbot_email: "{{ acme_email }}"
        # TODO: Can/should we do this as some other user? Not sure. What permissions would it need?
        certbot_auto_renew_user: root
      when: use_letsencrypt
      notify: Reload apache
      tags: acme

    # - name: Install Letsencrypt certificates
    #   ansible.builtin.import_tasks: acme.yml
    #   when: use_letsencrypt
    #   tags: acme

  handlers:

    - name: Reload apache
      ansible.builtin.service:
        name: apache2
        state: reloaded
