---
- name: Install a simple dev/test site on our dev servers only
  hosts: all
  become: true

  vars_files:
    - vars.yml

  tasks:
    - name: Create default site folder
      ansible.builtin.file:
        path: "{{ dev_site_path }}"
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: Create corresponding well-known directory with acme-challenge subdirectory
      ansible.builtin.file:
        path: "{{ well_known_dir }}/acme-challenge"
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: Template standard security.txt to well-known directory
      ansible.builtin.template:
        src: security.txt.j2
        dest: "{{ well_known_dir }}/security.txt"
        owner: root
        group: root
        mode: '0644'

    - name: Install default site index
      ansible.builtin.template:
        src: index.html.j2
        dest: "{{ dev_site_path }}/index.html"
        owner: root
        group: root
        mode: '0644'

    - name: Install default site http configuration
      ansible.builtin.template:
        src: "dev.conf.j2"
        dest: "{{ php_apache_server_root }}/sites-available/{{ dev_conf_name }}"
        owner: root
        group: root
        mode: '0644'
      notify: Reload apache

    - name: Install default site http configuration
      ansible.builtin.template:
        src: "dev-ssl.conf.j2"
        dest: "{{ php_apache_server_root }}/sites-available/{{ dev_conf_ssl_name }}"
        owner: root
        group: root
        mode: '0644'
      notify: Reload apache

    # TODO: Disable dev site (http and https) if not in production

    # We'll need the http site up and running before we can pass an ACME challenge.
    - name: Enable default non-https site
      ansible.builtin.command: a2ensite {{ dev_conf_name }}
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # BEFORE we enable the ssl site we've got to provide a self-signed certificate
    # if no SSL certificate is present yet. Later if necessary we can regenerate
    # the certificate with a real one from Let's Encrypt.

    # For this initial key we'll only create it if there's no key certificate of any
    # kind yet.
    - name: Check if any kind of certificate exists
      ansible.builtin.stat:
        path: "{{ dev_cert_path }}"
      register: cert_path

    - name: Create self-signed cert only if we don't already have a cert of any kind
      when: "not cert_path.stat.exists"
      block:
        - name: Create private key for a self-signed certificate (RSA, 4096 bits)
          community.crypto.openssl_privatekey:
            path: "{{ dev_key_path }}"
            # Because we don't want to overwite a valid Let's Encrypt certificate
            # so we only create the key if there's nothing there at all yet.
            regenerate: never
            type: RSA
          notify: Reload apache
        - name: Create CSR for simple self-signed certificate
          community.crypto.openssl_csr_pipe:
            privatekey_path: "{{ dev_key_path }}"
            common_name: "{{ dev_server_name }}"
            authority_cert_issuer:
              - "{{ self_signed_ca_DNS }}"
            authority_cert_serial_number: 123
          register: result
        - name: Print CSR
          ansible.builtin.debug:
            var: result.csr
        - name: Create simple self-signed certificate
          community.crypto.x509_certificate:
            path: "{{ dev_cert_path }}"
            csr_content: "{{ result.csr }}"
            privatekey_path: "{{ dev_key_path }}"
            provider: selfsigned

          notify: Reload apache

    - name: Enable default-ssl site
      ansible.builtin.command: "a2ensite {{ dev_conf_ssl_name }}"
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # At this point we should be able to get our site up and running enough to
    # pass an ACME challenge, so run handlers to reload apache and get the site
    # up and running.
    - name: Flush handlers
      ansible.builtin.meta: flush_handlers

    # Okay, so now we've got both http and https sites up and running. Now let's get ourselves
    # a real certificate from Let's Encrypt.

    - name: "Create required directories"
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: u=rwx,g=x,o=x
      with_items:
        - "{{ letsencrypt_account_dir }}"
        # - certs
        # - csrs
        # - keys

    # TODO This generates the key every time. We should only do this if the key file doesn't exist at all
    - name: Generate a Letsencrypt Account Key (RSA, 4096 bits is the default)
      community.crypto.openssl_privatekey:
        path: "{{ letsencrypt_account_key_file }}"
        regenerate: never

    - name: Generate an OpenSSL private key with the default values (4096 bits, RSA)
      community.crypto.openssl_privatekey:
        path: "{{ dev_key_path }}"

    - name: Generate an OpenSSL Certificate Signing Request
      community.crypto.openssl_csr_pipe:
        privatekey_path: "{{ dev_key_path }}"
        common_name: "{{ dev_server_name }}"
        # TODO:
        # subject_alt_name
      register: csr

    - name: Print CSR
      ansible.builtin.debug:
        var: csr.csr

    - name: Get certificate information
      community.crypto.x509_certificate_info:
        path: "{{ dev_cert_path }}"
      register: cert_info

    - name: Print existing certificate information
      ansible.builtin.debug:
        var: cert_info

    - name: Print existing certificate information
      ansible.builtin.debug:
        var: cert_info['authority_cert_issuer']

    - name: Create an ACME challenge for sample.com using a account key file.
      community.crypto.acme_certificate:
        # Staging environment for testing
        acme_directory: "https://acme-staging-v02.api.letsencrypt.org/directory"
        # Live environment
        # acme_directory: "https://acme-v02.api.letsencrypt.org/directory"
        acme_version: 2
        # Force an ACME certificate if it was we who self-signed the existing certificate
        force: "{{ self_signed_ca_DNS in cert_info['authority_cert_issuer'] }}"
        account_key_src: "{{ letsencrypt_account_key_file }}"
        csr_content: "{{ csr.csr }}"
        fullchain_dest: "{{ dev_cert_path }}"
      register: dev_server_challenge

    - name: Debug challenge data
      ansible.builtin.debug:
        var: dev_server_challenge

    - name: Copy http-01 challenge for dev server (if we've actually been challenged)
      ansible.builtin.copy:
        # /var/www/html/{{ sample_com_challenge['challenge_data']['sample.com']['http-01']['resource'] }}
        dest: "{{ well_known_dir || (dev_server_challenge['challenge_data'][dev_server_name]['http-01']['resource'] | basename) }}"
        content: "{{ sample_com_challenge['challenge_data']['sample.com']['http-01']['resource_value'] }}"
        owner: root
        group: root
        mode: '0644'
      when: dev_server_challenge is changed and dev_server_name in sample_com_challenge['challenge_data']

    - name: Let the challenge be validated and retrieve the cert and intermediate certificate
      community.crypto.acme_certificate:
        # Staging environment for testing
        acme_directory: "https://acme-staging-v02.api.letsencrypt.org/directory"
        # Live environment
        # acme_directory: "https://acme-v02.api.letsencrypt.org/directory"
        acme_version: 2
        account_key_src: "{{ letsencrypt_account_key_file }}"
        csr_content: "{{ csr.csr }}"
        fullchain_dest: "{{ dev_cert_path }}"
        data: "{{ dev_server_challenge }}"

    # Now we need to pass the challenge
    # Resource: /.well-known/acme-challenge/{{ token }}

  handlers:

    - name: Reload apache
      ansible.builtin.service:
        name: apache2
        state: reloaded
