---
- name: Install a simple dev/test site on our dev servers only
  hosts: all
  become: true

  vars_files:
    - vars.yml

  tasks:
    - name: Create default site folder
      ansible.builtin.file:
        path: "{{ dev_site_path }}"
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: Create corresponding well-known directory with acme-challenge subdirectory
      ansible.builtin.file:
        path: "{{ well_known_dir }}/{{ dev_server_name }}/acme-challenge"
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: Template standard security.txt to well-known directory
      ansible.builtin.template:
        src: security.txt.j2
        dest: "{{ well_known_dir }}/{{ dev_server_name }}/security.txt"
        owner: root
        group: root
        mode: '0644'

    - name: Install default site index
      ansible.builtin.template:
        src: index.html.j2
        dest: "{{ dev_site_path }}/index.html"
        owner: root
        group: root
        mode: '0644'

    - name: Install default site http configuration
      ansible.builtin.template:
        src: "dev.conf.j2"
        dest: "{{ php_apache_server_root }}/sites-available/{{ dev_conf_name }}"
        owner: root
        group: root
        mode: '0644'
      notify: Reload apache

    - name: Install default site http configuration
      ansible.builtin.template:
        src: "dev-ssl.conf.j2"
        dest: "{{ php_apache_server_root }}/sites-available/{{ dev_conf_ssl_name }}"
        owner: root
        group: root
        mode: '0644'
      notify: Reload apache

    # TODO: Disable dev site (http and https) if not in production

    # We'll need the http site up and running before we can pass an ACME challenge.
    - name: Enable default non-https site
      ansible.builtin.command: a2ensite {{ dev_conf_name }}
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # BEFORE we enable the ssl site we've got to provide a self-signed certificate
    # if no SSL certificate is present yet. Later if necessary we can regenerate
    # the certificate with a real one from Let's Encrypt.

    # For this initial key we'll only create it if there's no key certificate of any
    # kind yet.
    - name: Check if any kind of certificate exists
      ansible.builtin.stat:
        path: "{{ dev_cert_path }}"
      register: cert_path

    # - name: Get certificate information
    #   when: cert_path.stat.exists
    #   community.crypto.x509_certificate_info:
    #     path: "{{ dev_cert_path }}"
    #   register: cert_info

    # - name: Print existing certificate information
    #   ansible.builtin.debug:
    #     var: cert_info

    - name: Create self-signed cert only if we don't already have a cert of any kind
      when: "not cert_path.stat.exists"
      block:
        - name: Create private key for a self-signed certificate (RSA, 4096 bits)
          community.crypto.openssl_privatekey:
            path: "{{ dev_key_path }}"
            # Because we don't want to overwite a valid Let's Encrypt certificate
            # so we only create the key if there's nothing there at all yet.
            regenerate: never
            type: RSA
          notify: Reload apache
        - name: Create CSR for simple self-signed certificate
          community.crypto.openssl_csr_pipe:
            privatekey_path: "{{ dev_key_path }}"
            common_name: "{{ dev_server_name }}"
            authority_cert_issuer:
              - "{{ self_signed_ca_DNS }}"
            authority_cert_serial_number: 123
          register: result
        - name: Print CSR
          ansible.builtin.debug:
            var: result.csr
        - name: Create simple self-signed certificate
          community.crypto.x509_certificate:
            path: "{{ dev_cert_path }}"
            csr_content: "{{ result.csr }}"
            privatekey_path: "{{ dev_key_path }}"
            provider: selfsigned
          notify: Reload apache

    - name: Enable default-ssl site
      ansible.builtin.command: "a2ensite {{ dev_conf_ssl_name }}"
      register: site_result
      notify: Reload apache
      changed_when: "'Enabling site' in site_result.stdout"

    # At this point we should be able to get our site up and running enough to
    # pass an ACME challenge, so run handlers to reload apache and get the site
    # up and running.
    - name: Flush handlers
      ansible.builtin.meta: flush_handlers

    - name: Install Letsencrypt certificate
      ansible.builtin.import_tasks: acme.yml
      when: use_letsencrypt

  handlers:

    - name: Reload apache
      ansible.builtin.service:
        name: apache2
        state: reloaded
