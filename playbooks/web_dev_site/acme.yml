---
# Okay, so now we've got both http and https sites up and running. Now let's get ourselves
# a real certificate from Let's Encrypt, assuming we're not on the Vagrant box, where it's
# impossible to pass the acme challenge as that's inside our firewall and DNS won't be
# pointing to it anyway.

# TODO This seems to generate a key every time. I don't think it changes the
# existing one, though. Double-check. And can we not bother with the slow
# generation?
- name: Generate a Letsencrypt Account Key (RSA, 4096 bits is the default)
  community.crypto.openssl_privatekey:
    path: "{{ acme_account_key_file }}"
    regenerate: never

# TODO: I think we should do this for all sites *and* all aliases, not just the main site.
- name: Inspect existing certificate information for all sites
  # A certificate should always exist, but it might be self-signed. We only
  # want to generate a new one if it's self-signed.
  community.crypto.x509_certificate_info:
    path: "{{ acme_certs_dir }}/{{ site.server_name }}.crt"
  register: existing_cert_info
  with_items: "{{ websites }}"
  loop_control:
    loop_var: site

- name: Print existing certificate information
  ansible.builtin.debug:
    var: existing_cert_info.results

- name: Record current certificate issuers for each site so we can tell if it's self-signed later
  ansible.builtin.set_fact:
    # Dictionary of server name to list of issuers
    cert_issuers: >-
      {{ dict(existing_cert_info.results | map(attribute='site.server_name') |
          zip(existing_cert_info.results | map(attribute='authority_cert_issuer') ))
      }}

- name: Print issuer details
  ansible.builtin.debug:
    var: cert_issuers

- name: Generate OpenSSL private keys with the default values for all sites (4096 bits, RSA)
  # This should leave any existing keys alone if they don't need to be regenerated.
  community.crypto.openssl_privatekey:
    path: "{{ acme_keys_dir }}/{{ site.server_name }}.key"
  with_items: "{{ websites }}"
  loop_control:
    loop_var: site

- name: Generate OpenSSL Certificate Signing Requests for all sites
  community.crypto.openssl_csr:
    path: "{{ acme_csr_dir }}/{{ site.server_name }}.csr"
    privatekey_path: "{{ acme_keys_dir }}/{{ site.server_name }}.key"
    common_name: "{{ site.server_name }}"
    email_address: "{{ acme_email }}"
    organization_name: "{{ acme_organisation }}"
    country_name: GB
    subject_alt_name: "{{ ([site.server_name] + (site.aliases | default([]))) | map('regex_replace', '^', 'DNS:') | list }}"
  register: requests
  with_items: "{{ websites }}"
  loop_control:
    loop_var: site

- name: Print CSR details
  ansible.builtin.debug:
    var: requests.results

- name: Create ACME challenges for all sites as necessary
  community.crypto.acme_certificate:
    acme_directory: "{{ acme_directory }}"
    acme_version: 2
    terms_agreed: true
    # This won't deliver a new certificate if there's already a self-signed one
    # in place unless we detect that and force it.
    force: "{{ self_signed_ca_DNS in cert_issuers[csr.site.server_name] }}"
    account_key_src: "{{ acme_account_key_file }}"
    csr: "{{ acme_csr_dir }}/{{ csr.site.server_name }}.csr"
    fullchain_dest: "{{ acme_certs_dir }}/{{ csr.site.server_name }}.crt"
  register: acme_results
  with_items: "{{ requests.results }}"
  loop_control:
    loop_var: csr

- name: Debug challenge data
  ansible.builtin.debug:
    var: acme_results

- name: test fact
  ansible.builtin.set_fact:
    challenges: >-
      {{
        challenges | default([]) +
        [ item.challenge_data.values() | map('combine', { 'server_name': item.csr.site.server_name }) ]
      }}
  when: item is changed and item.challenge_data is defined
  with_items: "{{ acme_results.results }}"

- name: Print test fact
  ansible.builtin.debug:
    # var: ch
    msg: "{{ challenges | flatten }}"

- name: Copy http-01 challenges for all servers into the right places (if we've actually been challenged)
  ansible.builtin.copy:
    # /var/www/html/{{ sample_com_challenge['challenge_data']['sample.com']['http-01']['resource'] }}
    # dest: "{{ acme_challenge_dir }}/{{ (dev_server_challenge['challenge_data'][dev_server_name]['http-01']['resource'] | basename) }}"
    dest: "{{ acme_well_known_dir }}/{{ site.server_name }}/acme-challenge/{{ (site['http-01']['resource'] | basename) }}"
    content: "{{ site['http-01']['resource_value'] }}"
    owner: root
    group: root
    mode: '0644'
  loop: "{{ challenges | flatten }}"
  loop_control:
    loop_var: site

# - name: Let the challenge be validated and retrieve the cert and intermediate certificate
#   community.crypto.acme_certificate:
#     terms_agreed: true
#     acme_directory: "{{ acme_directory }}"
#     acme_version: 2
#     # This won't deliver a new certificate if there's already a self-signed one
#     # in place unless we detect that and force it.
#     force: "{{ self_signed_ca_DNS in cert_info['authority_cert_issuer'] }}"
#     account_key_src: "{{ letsencrypt_account_key_file }}"
#     csr_content: "{{ csr.csr }}"
#     fullchain_dest: "{{ dev_cert_path }}"
#     data: "{{ dev_server_challenge }}"
#   notify: Reload apache

- name: debug
  ansible.builtin.debug:
    msg: "{{ item.csr.site.server_name }}"
  with_items: "{{ acme_results.results }}"

- name: Let the challenge be validated and retrieve the cert and intermediate certificate
  community.crypto.acme_certificate:
    acme_directory: "{{ acme_directory }}"
    acme_version: 2
    terms_agreed: true
    # This won't deliver a new certificate if there's already a self-signed one
    # in place unless we detect that and force it.
    force: "{{ self_signed_ca_DNS in cert_issuers[item.csr.site.server_name] }}"
    account_key_src: "{{ acme_account_key_file }}"
    csr: "{{ acme_csr_dir }}/{{ item.csr.site.server_name }}.csr"
    fullchain_dest: "{{ acme_certs_dir }}/{{ item.csr.site.server_name }}.crt"
  with_items: "{{ acme_results.results }}"
  when: item is changed
